# MathBoxLib - Platform-Independent LaTeX Rendering Library

A platform-independent C++ library for parsing and typesetting LaTeX mathematical expressions, with C-ABI interface for cross-language integration.

## Overview

**MathBoxLib** is a C++ dynamic library (DLL) that provides:
- Complete LaTeX parser with macro system
- TeX typesetting engine following TeXbook specifications
- Platform-agnostic rendering interface via abstract C++ classes
- **C-ABI interface** (`MathBox_CAPI.h`) for cross-language integration

The library exports a C-ABI that allows host applications to:
1. Provide document parameters via `MB_DocParams` structure
2. Implement font management via `MBI_FontManager` callbacks
3. Implement rendering via `MBI_DocRenderer` callbacks
4. Parse and render LaTeX mathematical expressions

## Font Data and Processing

The library uses the **Latin Modern Math** font family (**LMM**), which is free and comprehensively documented. **Host applications must provide the `LatinModernFonts/` folder** with all required font files and the glyph mapping table.

### Required Files in LatinModernFonts/

The host's `MBI_FontManager` implementation must load fonts from a directory containing:
- `latinmodern-math.otf` - Main math font
- `lmroman10-regular.otf` - Roman text font
- `lmroman10-bold.otf` - Bold text font
- `lmroman10-italic.otf` - Italic text font
- `lmsans10-regular.otf` - Sans-serif font
- `lmmonolt10-regular.otf` - Monospaced/typewriter font
- **`LatinModernMathGlyphs.csv`** - Glyph mapping table (generated by Python script)

### Glyph Table Structure

`LatinModernMathGlyphs.csv` contains records ordered by font Glyph Indexes (as used in DirectWrite/FreeType APIs):

| Field | Type | Description |
|-------|------|-------------|
| **Unicode_Codepoint** | uint32 | Unicode code point, if exists |
| **Glyph_Name** | string | Internal glyph name, if exists |
| **LaTeX_Command** | string | LaTeX command (e.g., `\mathexclam` for '!' U+0021) |
| **TeX_Atom_Class** | enum | TeX classification: 0=Ord(default), 1=Op, 2=Bin, 3=Rel, etc. |
| **TopAccentX** | int32 | Top accent vertical position, 0 if undefined |
| **Italic_Correction** | int32 | Italic correction value, 0 if undefined |

**Generation:**
The table is generated by the Python script `LMMGlyphInfo.py` located in `MathBoxLib\LMMGlyphInfo\` folder using the [fontTools](https://fonttools.readthedocs.io/) library.

**Note:** The CSV file is pre-generated and included in the repository. Regeneration is only needed if font files are updated.

## Architecture

### Core Interfaces and Types

#### Data Structures

**TexBox** - Basic TeX box metrics
```cpp
struct STexBox {
   int32_t nAdvWidth;     // Advance width (horizontal)
   int32_t nHeight;       // Total height
   int32_t nAscent;       // Distance from baseline to top
   // Computed: nDescent = nHeight - nAscent
};
```

**TexGlue** - Resizable horizontal spacing
```cpp
struct STexGlue {
   float fNorm;                  // Normal width
   float fStretchCapacity;       // Maximum stretch
   float fShrinkCapacity;        // Maximum shrink
   uint16_t nStretchOrder;       // Infinite stretch order (0, 1=fil, 2=fill, 3=filll)
   uint16_t nShrinkOrder;        // Infinite shrink order
};
```

**MathStyle** - TeX math styles
```cpp
enum EnumTexStyle {
   etsDisplay,      // Display style (\displaystyle)
   etsText,         // Text style (\textstyle)
   etsScript,       // Script style (\scriptstyle)
   etsScriptScript  // ScriptScript style (\scriptscriptstyle)
};

class CMathStyle {
   EnumTexStyle Style() const;
   bool IsCramped() const;         // Cramped variant
   float StyleScale() const;       // Size multiplier
   CMathStyle Superscript() const; // Style for superscripts
   CMathStyle Subscript() const;   // Style for subscripts (cramped)
   CMathStyle Numerator() const;   // Style for fraction numerators
   CMathStyle Denominator() const; // Style for denominators (cramped)
};
```

#### Abstract Base Classes

**MathItem** - Base class for all mathematical elements
```cpp
class CMathItem {
   virtual EnumMathItemType Type() const = 0;
   virtual void Draw(SPointF ptfAnchor, IDocRenderer& docr) = 0;
   
   const STexBox& Box() const;        // Bounding box
   const STexGlue* GetGlue() const;   // Glue (if applicable)
   const CMathStyle& GetStyle() const; // Math style
   void MoveTo(int32_t nX, int32_t nY); // Position within parent
};
```

**Item Types:**
- `eacWORD` - Text word or symbol
- `eacHBOX` - Horizontal box (container)
- `eacVBOX` - Vertical box (container)
- `eacGLUE` - Horizontal spacing
- `eacRULE` - Line/rule
- `eacINDEXED` - Item with sub/superscripts
- `eacACCENT` - Item with top accent
- `eacRADICAL` - Square root
- `eacTABLE` - Matrix/table/array
- `eacDELIM` - Delimiter (bracket)

#### Builder Interfaces

**IMathItemBuilder** - Interface for item construction
```cpp
class IMathItemBuilder {
   virtual CMathItem* Build(int& nIdx, const SParserContext& ctx) = 0;
   virtual bool CanBeEmpty() const { return false; }
};
```

**IParserAdapter** - Helper interface for parser operations
```cpp
class IParserAdapter {
   virtual CMathItem* ProcessGroup(int& nIdx, const SParserContext& ctx) = 0;
   virtual CMathItem* ProcessItemToken(int& nIdx, const SParserContext& ctx) = 0;
   virtual bool GetLength(const string& sVar, float& fPts) const = 0;
   virtual void SetLength(const string& sVar, float fPts) = 0;
};
```

#### Platform Abstraction Interfaces

**IDocParams** - Document parameters
```cpp
class IDocParams {
   virtual IFontManager& FontManager() = 0;
   virtual float DefaultFontSizePts() = 0;
   virtual int32_t MaxWidthFDU() = 0;
   virtual uint32_t ColorText() = 0;
   virtual uint32_t ColorBkg() = 0;
   virtual uint32_t ColorSelection() = 0;
};
```

**IFontManager** - Font provider
```cpp
class IFontManager {
   virtual uint32_t FontCount() const = 0;
   virtual bool GetFontIndices(int32_t nFontIdx, uint32_t count, 
                               const uint32_t* unicodes, uint16_t* out_indices) = 0;
   virtual bool GetGlyphRunMetrics(int32_t nFontIdx, uint32_t count, 
                                   const uint16_t* indices,
                                   MB_GlyphMetrics* out_metrics, 
                                   MB_Bounds* out_bounds) = 0;
};
```

**IDocRenderer** - Rendering interface
```cpp
class IDocRenderer {
   virtual void DrawLine(float x1, float y1, float x2, float y2, 
                        uint32_t style, float width, uint32_t argb) = 0;
   virtual void DrawRect(float l, float t, float r, float b, 
                        uint32_t style, float width, uint32_t argb) = 0;
   virtual void FillRect(float l, float t, float r, float b, uint32_t argb) = 0;
   virtual void DrawGlyphRun(int32_t font_idx, uint32_t count, 
                            const uint16_t* indices,
                            float base_x, float base_y, 
                            float scale, uint32_t argb) = 0;
};
```

### C-ABI Interface

**MBI_API** - C-compatible API for cross-language integration
```c
typedef struct MBI_API {
   uint32_t size_bytes;
   uint32_t abi_version;
   
   MB_RET (*createEngine)(const MB_DocParams* doc, MB_Engine* out_engine);
   void   (*destroyEngine)(MB_Engine engine);
   void   (*destroyMathItem)(MB_MathItem item);
   
   const char* (*getLastError)(MB_Engine engine, uint32_t* startPos, uint32_t* endPos);
   MB_RET (*addMacros)(MB_Engine engine, const char* szMacros, const char* szFileName);
   MB_RET (*parseLatex)(MB_Engine engine, const char* szText, MB_MathItem* out_item);
   
   uint32_t (*mathItemLineCount)(MB_MathItem item);
   MB_RET (*mathItemDraw)(MB_MathItem item, float x, float y, 
                         const MBI_DocRenderer* renderer);
   MB_RET (*mathItemDrawLines)(MB_MathItem item, float x, float y, 
                              int32_t line_start, int32_t line_end,
                              const MBI_DocRenderer* renderer);
   MB_RET (*mathItemSelect)(MB_MathItem item, float left, float top, 
                           float right, float bottom, uint32_t flags);
   MB_RET (*mathItemGetBox)(MB_MathItem item, float* left, float* top, 
                           float* right, float* bottom);
   MB_RET (*mathItemGetLineBox)(MB_MathItem item, int32_t line,
                               float* left, float* top, float* right, float* bottom);
} MBI_API;

// Get API entry point
const MBI_API* MB_GetApi();
```

**Return Codes:**
- `MBOK` (0) - Success
- `MB_BADPARAM` (1) - Invalid parameter
- `MB_HOSTERR` (4) - Host error (font/render)
- `MB_ERR` (5) - Generic error
- `MB_PARSER` (10) - Parse error
- `MB_PARSER_BADTOKEN` (11) - Invalid token
- `MB_PARSER_BADGROUP` (12) - Invalid group
- `MB_PARSER_BUILDING` (13) - Building error

## Parser Architecture

The LaTeX parser follows a multi-stage pipeline:

### 1. Tokenization (`CTokenizer`)

Converts input text into tokens with position tracking.

**Token Types:**
- `ettALNUM` - Alphanumeric text
- `ettNonALPHA` - Single non-alpha character
- `ettCOMMAND` - LaTeX command (`\command`)
- `ettSPACE` - Whitespace (multiple spaces = one token)
- `ettNUMBER` - Numeric literal
- `ettFB_OPEN`/`ettFB_CLOSE` - Figure braces `{` `}`
- `ettSB_OPEN`/`ettSB_CLOSE` - Square brackets `[` `]`
- `ettDOLLAR` - Math delimiter `$`
- `ettAMPERSAND` - Table column separator `&`
- `ettDBLBACKSLASH` - Table row separator `\\`
- `ettCOMMENT` - Comment (from `%` to end of line)

**Token Structure:**
```cpp
struct STexToken {
   EnumTexTokenType nType;  // Token type
   int32_t nPos;            // Position in input
   int32_t nLen;            // Length in characters
   int32_t nRefIdx;         // Reference index (for macro expansion)
};
```

### 2. Macro Loading (`CMacrosMgr`)

Manages external macro definition files:
```cpp
class CMacrosMgr {
   void addMacros(const char* szMacros, const char* szFileName);
   bool getTokenText(const STexToken& token, string& sText) const;
   bool getTokenSource(const STexToken& token, int32_t& nPos, string& sFileName) const;
};
```

### 3. Macro Expansion (`CMacroProcessor`)

Expands user-defined macros with parameter substitution:

**Macro Definition:**
```cpp
struct SMacroDef {
   int nNameTkIdx;      // Token index of macro name
   int nNumArgs;        // Number of required arguments
   int nDefArgTkIdx;    // Default optional argument token index (or 0)
   int nBodyTkIdx;      // Body start token index
};
```

**Expansion Process:**
1. Detect macro invocation
2. Collect arguments (mandatory and optional)
3. Substitute parameters (`#1`, `#2`, etc.) in body
4. Insert expanded tokens with reference tracking
5. Process recursively for nested macros

### 4. Grouping

Identifies balanced braces and nested structures:
- Figure brace groups `{...}`
- Square bracket groups `[...]` (for optional arguments)
- Math mode groups `$...$`, `$$...$$`
- Environment groups `\begin{...}...\end{...}`

### 5. Building (`CTexParser`)

Constructs MathItem tree via specialized builders:

**Mode Processors:**
- **CMathModeProcessor** - Math mode (`$...$`, `$$...$$`)
  - Handles operators, delimiters, scripts, accents
  - Manages math spacing and atom types
  
- **CTextModeProcessor** - Text mode
  - Font selection (`\textbf`, `\textit`, etc.)
  - Text accents (`\'`, `\^`, etc.)
  - Word wrapping and line breaking

**Specialized Builders:**
- **CFractionBuilder** - `\frac{num}{denom}`
- **CRadicalBuilder** - `\sqrt[n]{radicand}`
- **CAccentBuilder** - `\hat{x}`, `\tilde{x}`, etc.
- **CDelimiterBuilder** - `\left(...\right)`
- **CVBoxBuilder** - `\overset`, `\underset`, `\substack`
- **CHSpacingBuilder** - `\hskip`, `\hspace`
- **CTableBuilder** - `\begin{matrix}`, `\begin{array}`

## How to Build

### Prerequisites
- C++14 compiler
- Visual Studio 2022 (for Windows build)
- CMake 3.10+ (for cross-platform build - future support)

### Windows Build (Visual Studio)

1. **Open Solution**
   ```
   Open MathBoxDemo.sln in Visual Studio 2022
   ```

2. **Build MathBoxLib Project**
   ```
   Right-click MathBoxLib project ? Build (Ctrl+B)
   Or build entire solution (Ctrl+Shift+B)
   ```

**Output:**
- `MathBoxLib.dll` - Dynamic library with C-ABI interface
- `MathBoxLib.lib` - Import library for linking

### Integration in Your Project

**1. Link Against Library:**

Add to your project's linker input:
- `MathBoxLib.lib` (import library)
- Ensure `MathBoxLib.dll` is accessible at runtime (same directory as executable or in PATH)

**2. Include Headers:**
```cpp
#include "MathBox_CAPI.h"  // For C-ABI interface
```

**3. Implement Required Interfaces:**

Your host application **must** implement:

- **`MBI_FontManager`** - Font loading and glyph metrics provider
  - **Must load fonts from `LatinModernFonts/` directory**
  - **Must use `LatinModernMathGlyphs.csv` for glyph mappings**
  - Implement callbacks: `getFontsDir()`, `getFontIndices()`, `getGlyphRunMetrics()`
  
- **`MBI_DocRenderer`** - Rendering callbacks (lines, rectangles, glyph runs)
  - All coordinates in DIPs (Device Independent Pixels)
  - Implement callbacks: `drawLine()`, `drawRect()`, `fillRect()`, `drawGlyphRun()`

- **`MB_DocParams`** - Document parameters
  - Font size in points (`font_size_pts`)
  - Colors (text, background, selection)
  - Maximum width in FDU (optional, 0 = unlimited)
  - Embed `MBI_FontManager` instance

**4. Basic Usage Pattern:**

```cpp
// Get API entry point
const MBI_API* pAPI = MB_GetApi();
if (!pAPI || pAPI->abi_version != 1) {
   // Version mismatch or load failure
   return;
}

// Setup font manager (your implementation)
MBI_FontManager fontMgr = {
   .size_bytes = sizeof(MBI_FontManager),
   .fontCount = 6,  // LMM font count
   .getFontsDir = MyGetFontsDir,
   .getFontIndices = MyGetFontIndices,
   .getGlyphRunMetrics = MyGetGlyphRunMetrics
};

// Setup document parameters
MB_DocParams params = {};
params.size_bytes = sizeof(MB_DocParams);
params.font_size_pts = 24.0f;
params.max_width_fdu = 0;  // Unlimited
params.color_text_argb = 0xFF000000;  // Black
params.color_bkg_argb = 0xFFFFFFFF;   // White
params.color_selection_argb = 0xFF4040FF;  // Blue
params.font_mgr = fontMgr;

// Create engine
MB_Engine engine = nullptr;
MB_RET ret = pAPI->createEngine(&params, &engine);
if (ret != MBOK) {
   // Handle error
   return;
}

// Add macro definitions (optional but recommended)
std::string macros = LoadFile("Macros.mth");
pAPI->addMacros(engine, macros.c_str(), "Macros.mth");

// Parse LaTeX
MB_MathItem item = nullptr;
ret = pAPI->parseLatex(engine, "$$x^2 + y^2 = r^2$$", &item);
if (ret != MBOK) {
   // Get error details
   uint32_t startPos, endPos;
   const char* error = pAPI->getLastError(engine, &startPos, &endPos);
   // Display error to user
   pAPI->destroyEngine(engine);
   return;
}

// Setup renderer (your implementation)
MBI_DocRenderer renderer = {
   .size_bytes = sizeof(MBI_DocRenderer),
   .drawLine = MyDrawLine,
   .drawRect = MyDrawRect,
   .fillRect = MyFillRect,
   .drawGlyphRun = MyDrawGlyphRun
};

// Render at position (x=0, y=0)
pAPI->mathItemDraw(item, 0.0f, 0.0f, &renderer);

// Cleanup
pAPI->destroyMathItem(item);
pAPI->destroyEngine(engine);
```

**5. See Complete Example:**

The **MathBoxDemo** project provides a complete reference implementation:
- `CD2DFontManager` - DirectWrite-based font manager
- `CD2DRenderer` - DirectWrite-based renderer
- `CMathBoxHost` - C++ wrapper for C-ABI

See [MathBoxDemo/ReadMeDemo.md](../MathBoxDemo/ReadMeDemo.md) for details.

## Current Implementation Status

### ? Completed Features

**Parser & Tokenizer:**
- ? Full tokenization with position tracking
- ? Multi-stage parsing pipeline
- ? Comprehensive error reporting with stage tracking
- ? Comment handling

**Macro System:**
- ? `\newcommand` / `\renewcommand` with parameter substitution
- ? Optional arguments (`[default]`)
- ? `\let` command for aliasing
- ? `\setlength` / `\addtolength` for length variables
- ? Nested macro expansion
- ? Parameter substitution with `#1`, `#2`, ..., `#9`
- ? Token reference tracking for error reporting

**Math Mode:**
- ? Inline math (`$...$`) and display math (`$$...$$`)
- ? Superscripts and subscripts with proper positioning
- ? Style cramping for subscripts and denominators
- ? Multi-level scripts (e.g., `x_a^b_c`)

**Fractions:**
- ? `\frac{num}{denom}` with variable bar thickness
- ? `\dfrac` (display style) and `\tfrac` (text style)
- ? Nested fractions
- ? Generalized fractions (`_a^b` without base)

**Radicals:**
- ? `\sqrt{radicand}` with extensible radical symbol
- ? `\sqrt[n]{radicand}` with degree positioning
- ? Nested radicals
- ? Variable-size radical symbols

**Accents:**
- ? Top accents: `\hat`, `\tilde`, `\vec`, `\dot`, `\ddot`, `\bar`, `\acute`, `\grave`, `\check`, `\breve`
- ? Wide accents: `\widehat`, `\widetilde`, `\overline`
- ? Proper accent positioning using OpenType MATH table
- ? Text mode accents: `\'`, `\``, `\^`, `\"`, `\~`, `\=`, `\.`, `\u`, `\v`, `\H`, `\c`, `\d`, `\b`

**Delimiters:**
- ? `\left...\right` with auto-sizing
- ? Supported delimiters: `()`, `[]`, `\{\}`, `||`, `\langle\rangle`, `\lfloor\rfloor`, `\lceil\rceil`
- ? Variable-size delimiter glyphs
- ? Delimiter nesting

**Operators:**
- ? Large operators: `\int`, `\sum`, `\prod`, `\bigcup`, `\bigcap`, `\coprod`
- ? Limit positioning (above/below in display, side in text)
- ? `\limits` and `\nolimits` modifiers
- ? Function operators: `\sin`, `\cos`, `\tan`, `\log`, `\ln`, `\exp`, `\lim`, `\sup`, `\inf`, `\max`, `\min`, `\gcd`

**Spacing:**
- ? TeX glue with stretch and shrink
- ? `\hskip`, `\hspace` with dimensions
- ? Dimension parsing: `pt`, `cm`, `mm`, `in`, `em`, `ex`
- ? Variable references in dimensions
- ? Automatic math spacing based on atom types

**Boxes:**
- ? HBox (horizontal) with baseline alignment
- ? VBox (vertical) with centering
- ? `\overset`, `\underset`, `\stackrel`
- ? `\overbrace`, `\underbrace` with extensible braces

**Tables & Matrices:**
- ? `\begin{matrix}...\end{matrix}` and variants (`pmatrix`, `bmatrix`, `vmatrix`, `Vmatrix`)
- ? `\begin{array}{cols}...\end{array}` with column alignment
- ? `\begin{cases}...\end{cases}`
- ? Row/column separators (`&`, `\\`)
- ? Horizontal lines (`\hline`)
- ? Vertical lines in column specification

**Fonts:**
- ? Math fonts: `\mathbf`, `\mathrm`, `\mathit`, `\mathsf`, `\mathtt`
- ? Text fonts: `\text`, `\textbf`, `\textit`, `\textsf`, `\texttt`
- ? Blackboard bold: `\mathbb` (via macros)
- ? Automatic font selection based on context

**Symbols:**
- ? Greek letters: `\alpha`, `\beta`, `\gamma`, ..., `\Alpha`, `\Beta`, `\Gamma`, ...
- ? Binary operators: `\pm`, `\mp`, `\times`, `\div`, `\ast`, `\star`, `\circ`, `\bullet`, `\cap`, `\cup`, `\wedge`, `\vee`
- ? Relations: `\leq`, `\geq`, `\neq`, `\approx`, `\equiv`, `\sim`, `\cong`, `\in`, `\notin`, `\subset`, `\supset`
- ? Arrows: `\leftarrow`, `\rightarrow`, `\leftrightarrow`, `\Leftarrow`, `\Rightarrow`, `\Leftrightarrow`
- ? Misc symbols: `\infty`, `\partial`, `\nabla`, `\forall`, `\exists`, `\emptyset`, `\cdots`, `\ldots`, `\vdots`, `\ddots`

### ?? In Progress
- **Overlay/Decoration Commands** - `\boxed`, `\underline`, `\overline`, `\cancel`, `\sout`

### ?? Planned Features
- **Selection Support** - Text selection with rectangular bounds
- **Multi-line Environments** - `equation`, `align`, `gather` with equation numbering
- **Extendable Arrows** - `\xleftarrow`, `\xrightarrow` with above/below text
- **siunitx Commands** - Number and unit formatting
- **Color Support** - `\textcolor`, `\colorbox`, `\color`
- **Advanced Spacing** - `\!`, `\,`, `\:`, `\;`, `\quad`, `\qquad`, `\phantom`, `\hphantom`, `\vphantom`
- **Math Alphabets** - `\mathcal`, `\mathfrak`, `\mathscr` (requires additional fonts)

## References

This implementation follows specifications from:
- [[1]](https://visualmatheditor.equatheque.net/doc/texbook.pdf) *"The TeXbook"* by Donald Knuth (1986)
- [[2]](https://www.tug.org/TUGboat/tb27-1/tb86jackowski.pdf) *"Appendix G Illuminated"* by Bogus?aw Jackowski
- [[3]](https://www.ntg.nl/maps/38/03.pdf) *"OpenType Math Illuminated"* by Ulrik Vieth
- [[4]](https://learn.microsoft.com/en-us/typography/opentype/spec/math) *MATH - The Mathematical Typesetting Table* - Microsoft Typography
- [[5]](https://w3c.github.io/mathml-core/) *MathML Core Specifications* - W3C

## License

See main README.md for license information.
